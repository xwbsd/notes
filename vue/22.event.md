## 编译

在编译的 parse 阶段，会执行 processAttrs 方法

```javascript
// src/compiler/parser/index.js
export const onRE = /^@|^v-on:/;
export const dirRE = /^v-|^@|^:/;
export const bindRE = /^:|^v-bind:/;
const modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;
function processAttrs(el) {
  const list = el.attrsList;
  let i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      el.hasBindings = true;
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, "");
      }
      if (bindRE.test(name)) {
        // ...
      } else if (onRE.test(name)) {
        name = name.replace(onRE, "");
        addHandler(el, name, value, modifiers, false, warn);
      } else {
        // ...
      }
    } else {
      // ...
    }
  }
}

/**
 * 通过 parseModifiers 解析出修饰符
 */
function parseModifiers(naem /* string */) {
  const match = name.match(modifierRE);
  if (match) {
    const ret = {};
    match.forEach((m) => {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

// src/compiler/helpers.js
export function addHandler(
  el, // ASTElement
  name, // string
  value, // string
  modifiers, // ? ASTModifiers
  important, // ? boolean
  warn // ? function
) {
  modifiers = modifiers || emptyObject;
  // warn preventand passive modifier
  // warn(passive and prevent cannot be used together. passive handler cannot prevent default event)

  // check capture modifier
  /**
   * 根据 modifier 修饰符对事件名 name 做处理
   */
  if (modifiers.capture) {
    delete modifiers.capture;
    name = "!" + name; // mark the event as captured
  }
  if (modifiers.once) {
    delete modifiers.once;
    name = "~" + name; // mark the event as once
  }
  if (modifiers.passive) {
    delete modifiers.passive;
    name = "&" + name; // mark the event as passive
  }

  // normalize click.right and click.middle since they donot actually fire this is technically browser-specific, but at least for now browsers are the only target envs that have right/middle clicks
  if (name === "click") {
    if (modifiers.right) {
      name = "contextmenu";
      delete modifiers.right;
    } else if (modifiers.middle) {
      name = "mouseup";
    }
  }

  /**
   * 根据 modifier.native 判断是一个纯原生事件还是普通事件
   */
  let events;
  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (le.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  const newHandler = {
    value: value.trim(),
  };
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  /**
   * 按照 name 对事件做归类，并把回调函数的字符串保留到对应的事件中
   */
  const handlers = events[name];
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}
```

然后在 codegen 阶段，会在 genData 函数中根据 AST 元素节点上的 events 和 naiveEvents 生成 data 数据

```javascript
// src/compiler/codegen/index.js
export function genData(el /* ASTElement */, state /* CodegenState */) {
  let data = "{";
  // ...
  if (el.events) {
    data += `${genHandlers(el.events, fasle, state.warn)},`;
  }
  if (el.nativeEvents) {
    data += `${genHandlers(el.nativeEvents, true, state.warn)}`;
  }
  // ...
  return data;
}

// src/compiler/codegen/events.js
/**
 * 遍历 events 事件对象，调用 genHandler(name, evnets[name])
 */
export function genHandlers(
  events, // ASTElementHandlers
  isNative, // boolean
  warn // function
) {
  let res = isNative ? "nativeOn:{" : "on:{";
  for (const name in events) {
    res += `"${name}":${genHandler(name, events[name])},`;
  }
  return res.slice(0, -1) + "}";
}

const fnExpRE = /^\s*([\w$_]+|\([^])]*?\))\s*=>|^function\s*\(/;
const simplePathRE =
  /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;
function genHandler(
  name, // string
  handler // ASTElementHandler | ASTElementHandler[]
) {
  if (!handler) {
    return "function(){}";
  }
  /**
   * 如果 handler 是一个数组，遍历它然后递归调用 genHandler
   */
  if (Array.isArray(handler)) {
    return `[${handler.map((handler) => genHandler(name, handler)).join(",")}]`;
  }
  /**
   * 判断 handler.value 是一个函数的调用路径还是函数表达式
   */
  const isMethodPath = simplePathRE.test(handler.value);
  const isFunctionExpression = fnExpRE.test(handler.value);
  if (!handler.modifiers) {
    /**
     * 如果没有 modifiers
     * 根据 handler.value 的情况直接返回或者返回一个函数包裹的表达式
     */
    if (isMethodPath || isFunctionExpression) {
      return handler.value;
    }
    if (__WEEX__ && handler.params) {
      return genWeexHandler(handler.params, handler.value);
    }
    return `function($event){${handler.value}}`; // inline statement
  } else {
    /**
     * 否则对不同的 modifier 添加对应的代码串
     */
    let code = "";
    let genModifierCode = "";
    const keys = [];
    for (const key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === "exact") {
        const modifiers = handler.modifiers;
        genModifierCode += genGuard(
          ["ctrl", "shift", "alt", "meta"]
            .filter((keyModifier) => !modifier[keyModifier])
            .map((keyModifier) => `$event.${keyModifier}Key`)
            .join("||")
        );
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    const handlerCode = isMethodPath
      ? `return ${handler.value}($event)`
      : isFunctionExpression
      ? `return (${handler.value})($event)`
      : handler.value;
    if (__WEEX__ && handler.params) {
      return genWeexHandler(handler.params, code + handlerCode);
    }
    return `function($event){${code}${handlerCode}}`;
  }
}
```

## DOM 事件

Vue 的 patch 过程除解决 DOM 的渲染问题外，执行各种 module 钩子函数，用来处理 DOM 元素相关的属性、样式、事件等设置

```javascript
// src/platforms/web/runtime/modules/events.js
/**
 * 在 patch 过程中的创建阶段和更新阶段都会执行
 * vnode.data.on 指事件对象
 * target 指 vnode 的 DOM 对象
 * normalizeEvents 是对 v-model 相关的处理
 */
let target;
function updateDOMListeners(oldVnode, vnode /* VNodeWithData */) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  const on = vnode.data.on || {};
  const oldOn = oldVnode.data.on || {};
  target = vnode.elm;
  normalizeEvents(on); /*  */
  updateListeners(on, oldOn, add, remove, vnode.context);
  target = undefined;
}

// src/core/vdom/helpers/update-listeners.js
export function updateListeners(
  on, // object
  oldOn, // object
  add, // function
  remove, // function
  vm // Component
) {
  let name, def, cur, old, event;
  /**
   * 遍历 on 添加事件监听
   */
  for (name in on) {
    def = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (__WEEX__ && isPlainObject(def)) {
      cur = def.handler;
      event.params = def.params;
    }
    if (isUndef(cur)) {
      // warn(invalid handler for event ${event.name})
    } else if (isUndef(old)) {
      /**
       * 处理事件回调函数，执行 add 完成一次事件绑定
       */
      if (isUndef(cur.fns)) {
        /**
         * 第一次通过 createFnInvoker(cur) 创建一个回调函数
         */
        cur = on[name] = createFnInvoker(cur);
      }
      add(
        event.name,
        cur,
        event.once,
        event.capture,
        event.passive,
        event.params
      );
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  /**
   * 编译 oldOn 移除事件监听
   */
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove(event.name, oldOn[name], event.capture);
    }
  }
}

/**
 * 根据之前 addHandler 时在事件名上添加的特殊标识
 * 区分事件是否有 once, capture, passive 等修饰符
 */
const normalizeEvent = cached((name /* string */) => {
  const passive = name.charAt(0) === "&";
  name = passive ? name.slice(1) : name;
  const once = name.charAt(0) === "~"; // prefixed last, checked first
  name = once ? name.slice(1) : name;
  const capture = name.charAt(0) === "!";
  name = capture ? name.slice(1) : name;
  return {
    name,
    passive,
    once,
    capture,
  };
});

export function createFnInvoker (fns /* function | function[] */) {
  function invoker () {
    const fns = invoker.fns
    if (Array.isArray(fns)) {
      const cloned =fns.slice()
      for (let i = 0; i < cloned.length; i++) {
        clone[i].apply(null, arguments)
      }
    } else {
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns
  return invoker
}
```
