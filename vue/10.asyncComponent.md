## 异步组件

为了减少首屏代码体积，将把一些非首屏的组件设计成异步组件

```javascript
/**
 * Vue 注册的组件不再是一个对象，而是一个工厂函数
 * 函数有两个参数 resolve 和 reject
 * 函数内部用 setTimeout 模拟了异步，实际使用可能是通过动态请求异步组件的 JS 地址
 * 最终执行 resolve 方法，其参数就是异步组件对象
 */
Vue.component("async-component", function (resolve, reject) {
  // 这个特殊的 require 语法告诉 webpack 自动将编译后的代码分割成不同的块
  // 这些块将通过 Ajax 请求自动下载
  require(["./my-async-component"], resolve);
});
```

回顾组件的注册逻辑，将执行 createComponent 函数：

```javascript
// src/core/vdom/create-component.js
export function createComponent(Ctor, data, context, children, tag) {
  /**
   * 此时传入的 Ctor 是一个函数，所以不会执行 Vue.extend
   */
  if (isUndef(Ctor)) {
    return;
  }
  const baseCtor = context.$options._base;
  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }
  // ...
  // async component
  let asyncFactory;
  /**
   * 同样函数的 cid 是 undefined，进入了异步组件创建的逻辑
   */
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }
}
```

### 普通函数异步组件

> src/core/vdom/helpers/resolve-async-component.js

```javascript
export function resolveAsyncComponent(
  factory, // Function
  baseCtor, // Class<Component>
  context // Component
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }
  if (isDef(factory.resolved)) {
    return factory.resolved;
  }
  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }
  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    const contexts = (factory.contexts = [context]);
    let sync = true;

    const forceRender = () => {
      for (let i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    const resolve = once((res) => {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    const reject = once((reason) => {
      // warn(failed to resolve async component: reason)
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    const res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === "function") {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (
        isDef(res.cmponent) &&
        typeof res.component.then === "function"
      ) {
        res.component.then(resolve, reject);
        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }
        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(() => {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }
        if (isDef(res.timeout)) {
          setTimeout(() => {
            if (isUndef(factory.resolved)) {
              reject(
                process.env.NODE_ENV !== "production"
                  ? `timeout (${res.timeout}ms)`
                  : null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
```
