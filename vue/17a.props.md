## 规范化

初始化 props 之前，会在 mergeOptions 时对 props 做一次 normalize：

```javascript
// src/core/util/options.js
export function mergeOptions(
  parent, // Object
  child, // Object
  vm // ? Component
) {
  // ...
  normalizeProps(child, vm);
  // ...
}
/**
 * 把编写的 props 转成带有 type 的对象格式
 */
function normalizeProps(options /* object */, vm /* ? Component */) {
  const props = options.props;
  if (!props) return;
  const res = {};
  let i, val, name;
  if (Array.isArray(props)) {
    /**
     * 当 props 是数组，每一个数组元素 prop 只能是 string
     * 表示 prop 的 key 转成驼峰格式，类型为 null
     */
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === "string") {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== "production") {
        // warn('props must be strings when using arrat syntax')
      }
    }
  } else if (isPlainObject(props)) {
    /**
     * 当 props 是一个对象
     * 对于 props 每个 prop 的 key 转成驼峰，value 规范成一个对象
     */
    for (const key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  } else if (process.env.NODE_ENV !== "prodution") {
    // warn(`props expected an Array or an Object`)
  }
  options.props = res;
}
```

## 初始化

```javascript
export function initState(vm /* Component */) {
  // ...
  const opts = vm.$options;
  if (opts.props) initProps(vm, opts.props);
  // ...
}

function initProps(vm /* Component */, propsOptions /* object */) {
  const propsData = vm.$options.propsData || {};
  const props = (vm._props = {});
  // cache prop keys so that future props updates can iterate using Array instead of dynamic object key enumeration
  const keys = (vm.$options._propKeys = []);
  const isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  for (const key in propsOptions) {
    keys.push(key);
    const value = validateProp(key, propsOptions, propsData, vm);
    if (process.env.NODE_ENV !== "production") {
      const hyphenatedKey = hyphenate(key);
      if (
        isReservedAttribute(hyphenatedKey) ||
        config.isReservedAttr(hyphenatedKey)
      ) {
        // warn(${hyphenatedKey} is a reserved attribute and cannot be used as component prop)
      }
      defineReactive(props, key, value, () => {
        if (!isRoot && !isUpdatingChildComponent) {
          // warn(avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders, instead, use a data or computed property based on the prop's value)
        }
      });
    } else {
      defineReactive(props, key, value);
    }
    // static props are already proxied on the component's prototype during Vue.extend()
    if (!(key in vm)) {
      proxy(vm, `_props`, key);
    }
  }
  toggleObserving(true);
}
```

### 校验 validateProp

```javascript
export function validateProp(
  key, // string
  propsOptions, // object
  propsData, // object
  vm // ? Component
) {
  const prop = propsOptions[key];
  const absent = !hasOwn(propsData, key);
  let value = propsData[key];
  // boolean casting
  /**
   * 处理 boolean 类型的数据
   */
  const booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, "default")) {
      /**
       * 如果父组件没有传递这个 prop 数据，并且 props 没有设置 default
       * 则 value 为 false
       */
      value = false;
    } else if (value === "" || value === hyphenate(key)) {
      // only cast empty string/same name to boolean if boolean has higher priority
      /**
       * 没写属性值 或 与属性同名的值，另外 prop 的类型是 boolean 或 string
       * booleanIndex < stringIndex 时 value 为 true
       */
      const stringIndex = getTypeIndex(String, prop.key);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  /**
   * 处理默认数据
   */
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy, make sure to observe it
    const prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  /**
   * 在开发环境且非 weex 的环境下，执行 assertProp 做属性断言
   */
  if (
    process.env.NODE_ENV !== "production" &&
    // skip validation for weex recycle-list child component props
    !(__WEEX__ && isObject(value) && "@binding" in value)
  ) {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}
```

1. 通过 getTypeIndex 判断 prop 定义是否是 boolean 类型

```javascript
function getType(fn) {
  const match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
/**
 * props 类型定义可以是某个原生构造函数，也可以是原生构造函数的数组
 * props: {
 *   prop1: String,
 *   prop2: [Boolean, String]
 * }
 * 如果 expectedTypes 是单个构造函数，就执行 isSameType 判断是否同一类型
 * 否则，遍历 expectedTypes 数组，找到第一个相同类型并返回其索引
 */
function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  for (let i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }
  return -1;
}
```

2. 通过 getPropDefaultValue(vm, prop, key) 处理父组件未传值时的默认数据

```javascript
function getPropDefaultValue(
  vm, // ? Component
  prop, // PropOptions
  key // string
) {
  // no default, return undefined
  /**
   * 如果 prop 没有定义 default 属性，直接返回 undefined
   */
  if (!hasOwn(prop, "default")) {
    return undefined;
  }
  const def = prop.default;
  // warn(against non-factory defaults for Object & Array)

  // this raw prop value was also undefined from previous render, return previous default value to avoid unnecessary watcher trigger
  /**
   * 如果上一次组件渲染收到的 prop 值是 undefined
   * 直接返回上一次的默认值 prop._props[key]
   */
  if (
    vm &&
    vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key];
  }
  // call factory function for non-factory types, a value is Function if its prototype is function even across different execution context
  /**
   * 如果 def 是工厂函数且 prop 类型定义不是 Function
   * 返回工厂函数的返回值，否则返回函数本身
   */
  return typeof def === "function" && getType(prop.type) !== "Function"
    ? def.call(vm)
    : def;
}
```

3. 通过 assertProp 断言 prop 是否合法

```javascript
function assertProp(
  prop, // PropOptions
  name, // string
  value, // any
  vm, // ? Component
  absent // boolean
) {
  /**
   * 首先判断 prop 定义了 required 但是父组件没有传递这个 prop 数据
   * 输出警告
   */
  if (prop.required && absent) {
    // warn(missing required prop: ${name})
    return;
  }
  /**
   * value 为空且 prop 未定义 required
   * 直接返回
   */
  if (value == null && !prop.required) {
    return;
  }
  /**
   * 拿到 prop 定义的类型 type，并转成一个类型数组
   * 遍历这个数组执行 assertType(value, type[i]) 获取断言结果
   * 直到 valid 为 true 或者遍历完成
   */
  let type = prop.type;
  let valid = !type || type === true;
  const expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (let i = 0; i < type.length && !valid; i++) {
      const assertedType = assertProp(value, type[i]);
      expectedTypes.push(assertedType.expectedType || "");
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    // warn(getInvalidTypeMessage(name, value, expectedTypes))
    return;
  }
  /**
  * 最后判断当 prop 定义了 validator 自定义校验器
  * 执行 validator，如果不通过则输出警告
  */
  const validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      // warn(custom validator check failed for prop: ${name})
    }
  }
}

const simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/
function assertType(value /* any */, type /* Function */) {
  let valid
  const expectedType = getType(type)
  if (simpleCheckRE.test(expectedType)) {
    const t = typeof value
    valid = t === expectedType.toLowerCase()
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = valid instanceof type
    }
  } else if (expectedType === 'Object') {
    valid  = isPlainObject(value)
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value)
  } else {
    valid = value instanceof type
  }
  retur {
    valid,
    expectedType
  }
}
```
