编译的最后一步就是把优化的 AST 树转换成可执行的代码。

```html
<ul :class="bingCls" class="list" v-if="isShow">
  <li v-for="(item, index) in data" @click="clickItem(index)">
    {{item}}:{{index}}
  </li>
</ul>
```

例如把这段 template 转换成 render 代码

```javascript
with (this) {
  return isShow
    ? _c(
        "ul",
        {
          staticClass: "list",
          class: bindCls,
        },
        _l(data, function (item, index) {
          return _c(
            "li",
            {
              on: {
                click: function ($event) {
                  clickItem(index);
                },
              },
            },
            [_v(_s(item) + ":" + _s(index))]
          );
        })
      )
    : _e();
}
```

其中 \_c, \_l, \_v 分别定义在：

```javascript
// src/core/instance/render.js
vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false); // 创建 VNode

// src/core/instance/render-helpers/index.js
export function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList; // 渲染列表
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode; // 创建文本 VNode
  target._e = createEmptyVnode; // 创建控 VNode
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}
```

在 compileToFunctions 再把这个 render 代码串转换成函数

```javascript
// src/compiler/to-function.js
const compiled = compile(template, options);
res.render = createFunction(compiled.render, fnGenErrors);

/**
 * render 代码串通过 new Function 的方式转换成可执行的函数
 * 并赋值给 vm.options.render
 * 这样在组件 vm._render 时执行的就是这个 render 函数
 */
function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({ err, code });
    return noop;
  }
}
```
