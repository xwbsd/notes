## vm.\_update

私有方法 \_update 被调用的时机有 2 个：_首次渲染，数据更新_。用来把 VNode 渲染成真实的 DOM。

> src/core/instance/lifecycle.js

```javascript
Vue.prototype._update = function (vnode, hydrating) {
  const vm = this;
  const prevEl = vm.$el;
  const prevVnode = vm._vnode;
  const prevActiveInstance = activeInstance;
  activeInstance = vm;
  vm._vnode = vnode;

  // Vue.prototype.__patch__ is injected in entry points
  // based on the rendering backend used
  if (!prevVnode) {
    // initial render
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
  } else {
    // updates
    em.$el = vm.__patch__(prevVnode, vnode);
  }
  activeInstance = prevActiveInstance;
  // update __vue__ reference
  if (prevEl) {
    prevEl.__vue__ = null;
  }
  if (vm.$el) {
    vm.$el.__vue__ = vm;
  }
  // if parent is an HOC, update its $el as well
  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el;
  }
  // update hook is called by the scheduler to ensure that children are updated in a parent's updated hook
};
```

\_update 的核心就是调用 vm.**patch**，不同的平台定义 web、weex 也不一样

> src/platforms/web/runtime/index.js

```javascript
Vue.prototype.__patch__ = inBrowser ? patch : noop;
```

patch 在是否服务端渲染时也不一样

> src/platforms/web/runtime/patch.js

```javascript
import * as nodeOps from "web/runtime/node-ops";
import { createPatchFunction } from "core/vdom/patch";
import baseModules from "core/vdom/modules/index";
import platformModules from "web/runtime/modules/index";

// the directive module should be applied last, after all built-in modules have been applied
const modules = platformModules.concat(baseModules);

export const patch = createPatchFunction({ nodeOps, modules });
```
