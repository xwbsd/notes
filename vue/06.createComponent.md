回顾数据驱动的内容，`$mount -> vm._render -> vm.$createElement -> createElm/createComponent -> vm._update -> vm.__patch__`

```javascript
function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
  let i = vnode.data
  if (isDef(i)) {
    const isReactivated = isDef(vnode.componentInstance) && i.keepAlive
    /**
     * 如果 vnode 是一个组件 VNode，并且得到 i 就是 init 钩子函数
     * src/core/vdom/create-component.js 的 componentVNodeHooks 中
     */
    if (isDef((i = i.hook)) && isDef((i = i.init))) {
      i(vnode, false /* hydrating */)
    }
    // after calling the init hook, if the vnode is a child component, it should've created a child instance and mounted it. the child component also has set the placeholder vnode's elm.
    // in that case we can just return the element and be done.
    if (isDef(vnode.componentInstance)) {
      initComponent(vnode, insertedVnodeQueue)
      insert(parentElm, vnode.elm, refElm)
      if (isTrue(isReactivated)) {
        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
      }
      return true
    }
  }
}

const componentVNodeHooks = {
  //...
  init(vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      const mountedNode = vnode
      componentVNodeHooks.prepatch(mountedNode, mountedNode)
    } else {
      const child = (vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      ))
      child.$mount(hydrating ? vnode.elm : undefined, hydrating)
    }
  },
}

export function createComponentInstanceForVnode(vnode, parent) {
  // 构造一个内部组件的参数
  cosnt options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent
  }
  // check inline-template render functions
  const inlineTemplate = vnode.data.inlineTemplate
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render
    options.staticRenderFns = inlineTemplate.staticRenderFns
  }
  /**
  * vnode.componentOptions.Ctor 对应子组件的构造函数
  * 即继承于 Vue 的构造器 Sub
  */
  return new vnode.componentOptions.Ctor(options)
}
```

子组件在此实例化，并执行实例的 \_init 方法

```javascript
Vue.prototype._init = function (options) {
  const vm = this;
  // merge options
  if (options && options._isCOmponent) {
    // 组件合并 options 的过程有变化
    initInternalComponent(vm, options);
  } else {
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    );
  }
  // ...
  
  /**
   * 组件初始化的时候是不传 el 的，所以组件自己接管了 $mount 的过程
   * Vue.prototype._init
   */

  if (vm.$options.el) {
    vm.$mount(vm.$options.el);
  }
};

export function initInternalComponent(vm, options) {
  const opts = (vm.$options = Object.create(vm.constructor.options));
  // doing this because its faster than dynamic enumeration.
  const parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  const vnodeComponentOptions = parenVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

/**
 * 组件的 init 的过程
 * hydrating 为 true 一般是服务端渲染的情况
 * 客户端渲染在这里相当于 child.$mount(undefined, false)
 * componentVNodeHooks.init
 */
child.$mount(hydrating ? vnode.elm : undefined, hydrating);

/**
 * 回到 mountComponent 中，并执行 vm._update(vm._render(), hydrating)
 */
Vue.prototype._render = function () {
  const vm = this;
  const { render, _parentVnode } = vm.$options;

  // set parent vnode
  vm.$vnode = _parentVnode;
  // render self
  let vnode;
  try {
    vnode = render.call(vm._renderProxy, vm.$createElement);
  } catch (e) {
    // ...
  }
  // set parent
  vnode.parent = _parentVnode;
  // 即 vnode.parent === vm.$vnode
  return vnode;
};
export let activeInstance = null;
Vue.prototype._update = function (vnode, hydrating) {
  const vm = this;
  const prevEl = vm.$el;
  const prevVnode = vm._vnode;
  /**
   * activeInstance 用来保持当前上下文的 Vue 实例
   * 在调用 createComponentInstanceForVnode 时作为参数 parent 传入
   *
   */
  const prevActiveInstance = activeInstance;
  activeInstance = vm;
  // vnode 即组件 VNode，vm._vnode.parent === vm.$vnode
  vm._vnode = vnode;
  if (!prevVnode) {
    // initial render
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false);
  } else {
    // updates
    vm.$el = vm.__patch__(prevVnode, vnode);
  }
  activeInstance = prevActiveInstance;
  // update __vue__ reference
  if (prevEl) {
    prevEl.__vue__ = null;
  }
  if (vm.$el) {
    vm.$el.__vue__ = vm;
  }
  // if parent is an HOC, update its $el
  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el;
  }
  // children are updated in a parent's updated hook
};
```
