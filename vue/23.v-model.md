Vue 的响应式数据并不是双向绑定，响应式数据是通过数据的变化去驱动 DOM 视图的变化；

而双向数据绑定还能通过 DOM 的变化反过来影响数据，在 Vue 中通过 v-model 来实现

v-model 既可以用在普通表单元素上，又可以作用在组件上

## 表单元素

1. 在编译阶段，parse 将 v-model 当作普通的指令解析到 el.directives 中，然后在 codegen 中的 genData 函数中执行 const dirs = genDirectives(el, state)

```javascript
// src/compiler/codegen/index.js
function genDirectives(el /* ASTElement */, state /* CodegenState */) {
  const dirs = el.directives;
  if (!dirs) return;
  let res = "directives:[";
  let hasRuntime = false;
  let i, l, dir, needRuntime;
  /**
   * 遍历 el.directives，获取每一个指令对应的方法 gen = state.directives[dir.name]
   * 这个方法是在实例化 CodegenState 时通过 option 传入的
   */
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    const gen = state.directives[dir.name]; // DirectiveFunction
    if (gen) {
      // compile-time directive thar manipulates AST. returns true if it also needs a runtime counterpart
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += `{name:"${dir.name}",rawName:"${dir.rawName}"${
        dir.value
          ? `,value:(${dir.value}),expression:${JSON.stringify(dir.value)}`
          : ""
      }${dir.arg ? `,arg:"${dir.arg}"` : ""}${
        dir.modifiers ? `,modifiers:${JSON.stringify(dir.modifiers)}` : ""
      }},`;
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + "]";
  }
}
```

state.directives 中的方法是在实例化 CodegenState 时通过 option 传入的

```javascript
// src/platform/web/compiler/options.js
export const baseOptions /* CompilerOptions */ = {
  expectHTML: true,
  modules,
  directives,
  isPreTag,
  isUnaryTag,
  mustUseProp,
  canBeLeftOpenTag,
  isReservedTag,
  getTagNamespace,
  staticKeys: genStaticKeys(modules),
};

// src/platform/web/compiler/directives/index.js
export default {
  model,
  text,
  html
}

// src/platform/wen/compiler/directives/model.js
export default function model () {}
```
