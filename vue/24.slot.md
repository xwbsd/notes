## 普通插槽

### 编译

1. 编译的顺序是先编译父组件，再编译子组件。所以在编译父组件时，在 parse 阶段执行 processSlot 处理 slot

```javascript
// src/compiler/parser/index.js
/**
 * 当解析到 AST 元素节点有 slot 属性
 * 为节点添加 slotTarget 和 slotScope 属性
 */
function processSlot(el) {
  if (el.tag === "slot") {
    el.slotName = getBindingAttr(el, "name");
    // el.key && warn(key does not work on <slot> because slots are abstract outlets and can possibly expand into multiple elements)
  } else {
    let slotScope;
    if (el.tag === "template") {
      slotScope = getAndRemoveAttr(el, "scope");
      // slotScope && warn(the "scope" attribute for scoped slots have been deprecated and replaced by "slot-scope")
      el.slotScope = slotScope || getAndRemoveAttr(el, "slot-scope");
    } else if ((slotScope = getAndRemoveAttr(el, "slot-scope"))) {
      // el.attrsMap['v-for'] && warn(ambiguous combined usage of slot-scope and v-for on <${el.tag}> (v-for takes higher priority) use a wrapper <template> for the scoped slot to make it clearer)
      el.slotScope = slotScope;
    }
    const slotTarget = getBindingAttr(el, "slot");
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      // preserve slot as an attribute for native shadow DOM compat only for non-scoped slots
      if (el.tag !== "template" && !el.slotScope) {
        addAttr(el, "slot", slotScope);
      }
    }
  }
}
```

2. 在 codegen 阶段，在 genData 中会处理 slotTarget

```javascript
// src/compiler/codegen/index.js
if (el.slotTarget && !el.slotScope) {
  data += `slot:${el.slotTarget},`;
}
```

3. 接下来编译子组件，在 parser 阶段，当遇到 slot 标签时会给对应 AST 元素节点添加 slotName 属性

```javascript
function processSlot() {
  if (el.tag === "slot") {
    el.slotName = getBindingAttr(el, "name");
  }
  // ...
}
```

4. 在 codegen 阶段，会判断当前 AST 元素节点是否 slot 标签，是则执行 genSlot

```javascript
// src/compiler/codegen/index.js
function genSlot(el /* ASTElement */, state /* CodegenState */) {
  const slotName = el.slotName || '"default"';
  const children = genChildren(el, state);
  let res = `_t(${slotName}${children ? `,${children}` : ""}`;
  const attrs =
    el.attrs &&
    `{${el.attrs.map((a) => `${camelize(a.name)}:${a.value}`).join(",")}}`;
  const bind = el.attrsMap["v-bind"];
  if ((attrs || bind) && !children) {
    res += `,null`;
  }
  if (attrs) {
    res += `,${attrs}`;
  }
  if (bind) {
    res += `${attrs ? "" : ",null"},${bind}`;
  }
  return res + ")";
}
```

5. 暂不考虑 attrs 及 v-bind 的情况，返回的 res 将是一个 \_t 函数，对应的就是 renderSlot 方法

```javascript
// src/core/instance/render-helpers/render-slot.js
// runtime helper for rendering <slot>
/**
 * renderSlot 接收的 name 为插槽名称 slotName，fallback 为插槽的默认内容 vnode 数组
 */
export function renderSlot(
  name, // string
  fallback, // ? VNode[]
  props, // ? object
  bindObject // ? object
) {
  const scopedSlotFn = this.$scopedSlots[name];
  let nodes;
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      // !isObject(bindObject) && warn(slot v-bind without argument expects on Object)
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    /**
     * 默认插槽
     * 如果 this.$slot[name] 有值就返回它对应的 vnode 数组，否则返回默认内容 fallback
     */
    const slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes) {
      // slotNodes._rendered && warn(duplicate presence of slot ${name} found in the same render tree, this will likely cause render errors)
      slotNodes._rendered = true;
    }
    nodes = slotNodes || fallback;
  }

  const target = props && props.slot;
  if (target) {
    return this.$createElement("template", { slot: target }, nodes);
  } else {
    return nodes;
  }
}
```

6. this.$slot 在子组件的 init 过程中执行 initRender 时获取 vm.$slot

```javascript
// src/core/instance/render.js
export function initRender(vm /* Component */) {
  // ...
  const parentVnode = vm.$vnode + options._parentVnode; // this placeholder node in parent tree
  const renderContext = parentVnode && parentVnode.context;
  vm.$slot = resolveSlots(options._renderChildren, renderContext);
}

// src/core/instance/render-helpers/resolve-slot.js
// runtime helper for resolving raw children VNode into a slot object
/**
 * resolveSlots 参数接收父组件的 children，以及父组件的上下文 vm 实例
 * 所以子组件的 vm.$slots 可以拿到的父组件创建的 vnode 替换自身插槽
 */
export function resolveSlots(
  children, // ? VNode[]
  context // ? Component
) {
  const slots = {};
  if (!children) {
    return slots;
  }
  /**
   * 遍历 children，拿到每一个 child 及其 data
   * 以 data.slot 插槽名称为 key，child 为值，添加到 slots 中
   * 如果 data.slot 不存在则是默认插槽，以 default 为 key，添加 child
   * child 以数组的形式保存在 slots 的值，因为支持同名插槽的存在
   */
  for (let i = 0, l = children.length; i < l; i++) {
    const child = children[i];
    const data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the same context
    if (
      (child.context === context || child.fnContext === context) &&
      data &&
      data.slot != null
    ) {
      const name = data.slot;
      const slot = slots[name] || (slots[name] = []);
      if (child.tag === "template") {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (const name in slots) {
    if (slots[name].every(isWhitespace)) {
      delete slots[name];
    }
  }
  return slots;
}
```
