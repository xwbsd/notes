当数据发生变化，触发 watcher 的回调函数 updateComponent，进而执行组件的更新过程。

```javascript
updateComponent = () => {
  vm._update(vm, _render(), hydrating);
};

new Watcher(
  vm,
  updateComponent,
  noop,
  {
    before() {
      if (vm._isMounted) {
        callHook(vm, "beforeUpdate");
      }
    },
  },
  true /* isRenderWatcher */
);
```

1. 组件的更新调用了 vm._update 方法

```javascript
// src/core/instance/lifecycle.js
Vue.prototype._update = function (vnode, hydrating) {
  const vm = this
  // ...
  const prevVnode = vm._vnode
  if (!prevVnode) {
    // initial render
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // updates
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
}
```

2. _update 中继而调用了 patch 函数

```javascript
// src/core/vdom/patch.js
return function patch(oldVnode, vnode, hydrating, removeOnly) {
  if (isUndef(vnode)) {
    if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
    return
  }

  let isInitialPatch = false
  const insertedVnodeQueue = []

  if (isUndef(oldVnode)) {
    // empty mount (likely as component), create new root element
    isInitialPatch = true
    createElm(vnode, insertedVnodeQueue)
  } else {
    const isRealElement = isDef(oldVnode.nodeType)
    if (!isRealElement && sameVnode(oldVnode, vnode)) {
      // patch existing root node
      patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)
    } else {
      if (isRealElement) {
        // ...
      }

      // replacing existing element
      /**
       * 新旧节点不同即替换旧节点
       * 1. 创建新节点
       */
      const oldElm = oldVnode.elm
      const parentElm = nodeOps.parentNode(oldElm)

      // create new node
      createElm(
        vnode,
        insertedVnodeQueue,
        // extremely rare edge case: donot insert if old element is in a leaving transition. only happens when combining transition + keep-alive + HOCs
        oldElm._leaveCb ? null : parentElm,
        nodeOps.nextSibling(oldElm)
      )

      // update parent placeholder node element, recursively
      /**
       * 2. 更新父级占位符节点
       * 找到当前 vnode 的父占位符节点，执行各个 module 的 destroy 钩子函数
       * 如果当前占位符是一个可挂载的节点，则执行 module 的 create 钩子函数
       */
      if (isDef(vnode.parent)) {
        let ancestor = vnode.parent
        const patchable = isPatchable(vnode)
        while (ancestor) {
          for (let i = 0; i < cbs.destory.length; ++i) {
            cbs.destroy[i](ancestor)
          }
          ancestor.elm = vnode.elm
          if (patchable) {
            for (let i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode.ancestor)
            }
            // invoke insert hooks that may have been merged by create hooks.
            // e.g. for directives that uses the "inserted" hook.
            const insert = ancestor.data.hook.insert
            if (insert.merged) {
              // start at index 1 to avoid re-invoking component mounted hook
              for (let i = 1; i < insert.fns.length; i++) {
                insert.fns[i]()
              }
            }
          } else {
            registerRef(ancestor)
          }
          ancestor = ancestor.parent
        }
      }

      // destroy old node
      /**
       * 3. 删除旧节点
       * 如果父节点存在，则执行 removeVnodes 方法
       */
      if (isDef(parentElm)) {
        removeVnodes(parentElm, [oldVnode], 0, 0)
      } else if (isDef(oldVnode.tag)) {
        invokeDestroyHook(oldVnode)
      }
    }
  }

  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
  return vnode.elm
}
```

上面执行 patch 与首次渲染不一样，因为 oldVnode 不为空，并且它和 vnode 都是 VNode 类型，接下来会通过 sameVNode(oldVnode, vnode) 判断它们是否是相同的 VNode 来决定不同的更新逻辑：

```javascript
/**
 * 如果两个 vnode 的 key 不相等则是不同的
 * 否则判断同步组件的 isComment, data, input 是否相等
 * 或是异步组件的 asyncFactory 是否相同
 */
function sameVnode(a, b) {
  return (
    a.key === b.key &&
    ((a.tag === b.tag &&
      a.isComment === b.isComment &&
      isDef(a.data) === isDef(b.data) &&
      sameInputType(a, b)) ||
      (isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.astncFactory &&
        isUndef(b.asyncFactory.error)))
  )
}
```

最后通过 removeVnodes 删除旧节点，即遍历待删除的 vnodes 做删除。

```javascript
function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    const ch = vnodes[startIdx]
    if (isDef(ch)) {
      if (isDef(ch.tag)) {
        removeAndInvokeRemoveHook(ch)
        invokeDestroyHook(ch)
      } else {
        /**
         * DOM 原生 API 移除真正的 DOM 节点
         */
        removeNode(ch.elm) /* text node */
      }
    }
  }
}

/**
 * 从 DOM 中移除节点并执行 module 的 remove 钩子函数
 * 并对其子节点递归调用 removeAndInvokeRemoveHook 函数
 */
function removeAndInvokeRemoveHook(vnode, rm) {
  if (isDef(rm) || isDef(vnode.data)) {
    let i
    const listeners = cbs.remove.length + 1
    if (isDef(rm)) {
      // we have a recursively passed down rm callback increase the listeners count
      rm.listeners += listeners
    } else {
      // directly removing
      rm = createRmCb(vnode.elm, listeners)
    }
    // recursively invoke hooks on child component root node
    if (
      isDef((i = vnode.componentInstantce)) &&
      isDef((i = i._vnode)) &&
      isDef(i.data)
    ) {
      removeAndInvokeRemoveHook(i, rm)
    }
    for (i = 0; i < cbs.remove.length; ++i) {
      cbs.remove[i](vnode, rm)
    }
    if (isDef((i = vnode.data.hook)) && isDef((i = i.remove))) {
      i(vnode, rm)
    } else {
      rm()
    }
  } else {
    removeNode(vnode.elm)
  }
}

/**
 * 执行 module 的 destroy 钩子函数以及 vnode 的 destroy 钩子函数
 * 并对其子 vnode 递归调用 invokeDestroyHook 函数
 */
function invokeDestroyHook(vnode) {
  let i, j
  const data = vnode.data
  if (isDef(data)) {
    if (isDef((i = data.hook)) && isDef((i = i.destroy))) i(vnode)
    for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode)
  }
  if (isDef((i = vnode.children))) {
    for (j = 0; j < vnode.chidlren.length; ++j) {
      invokeDestroyHook(vnode.chidlren[j])
    }
  }
}
```

组件的 beforeDestroy & destroyed 生命周期钩子函数就是在 invikeDestroyHook 中执行了 vnode 的 destroy 钩子函数：

```javascript
// src/core/vdom/create-component.js
const componentVNodeHooks = {
  // ...
  destroy(vnode /* MountedComponentVNode */) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      /**
       * 当组件不是 keepAlive 时，执行 $destroy 方法
       * 然后就会执行 beforeDestroy & destroyed
       */
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy()
      } else {
        deactivateChildComponent(componentInstance, true /* direct */)
      }
    }
  },
}
```
