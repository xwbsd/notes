## 安装

安装 Vuex 实际引用的是一个对象，其中和 Vue-Router 一样存在一个静态方法 install

```javascript
import Vuex from "vuex"

// src/index.js
export default {
  Store,
  install,
  version: "",
  mapState,
  mapMutations,
  mapGetters,
  mapActions,
  createNamespacedHelpers,
}

// src/store.js
export function install(_Vue) {
  if (Vue && _Vue === Vue) {
    // warn(vuex already installed)
    return
  }
  Vue = _Vue
  applyMixin(Vue)
}
```

applyMixin 兼容了 Vue1.x 的版本，实现过程为全局混入 beforeCreate 钩子函数 vuexInit

```javascript
// src/mixin.js
export default function (Vue) {
  const version = Number(Vue.version.split(".")[0])

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit })
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility
    const _init = Vue.prototype._init
    Vue.prototype._init = function (options = {}) {
      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit
      _init.call(this, options)
    }
  }

  // Vuex init hook injected into each instances init hooks list
  /**
   * 把 options.store 保存在所有组件的 this.$store 中
   * options.store 就是实例化 Store 对象的实例
   */
  function vuexInit() {
    const options = this.$options
    // store injection
    if (options.store) {
      this.$store =
        typeof options.store === "function" ? options.store() : options.store
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store
    }
  }
}
```

## Store

使用 Vuex 时需 new Vuex.Store({}) 并传入 state, actions, mutations 等参数

```javascript
// src/store.js
export class Store {
  constructor(options = {}) {
    // auto install if it is not done yet and `window` has `vue`
    // to allow users to avoid auto-installation in some cases
    if (!Vue && typeof window !== "undefined" && window.Vue) {
      install(window.Vue)
    }

    // Vue ? warn(must call Vue.use(Vuex) before creating a store instance)
    // typeof Promise !== 'undefined' ? warn(vuex requires a Promise polyfill in this browser)
    // this instanceof Store ? warn(Store must be called with the new operator)

    const { plugins = [], strict = false } = options

    // store internal state
    this._committing = false
    this._actions = Object.create(null)
    this._actionSubscribers = []
    this._mutations = Object.create(null)
    this._wrappedGetters = Object.create(null)
    /**
     * 初始化模块
     */
    this._modules = new ModuleCollection(options)
    this._modulesNamespaceMap = Object.create(null)
    this._subscribers = []
    this._watcherVM = new Vue()

    // bind commit and dispatch to self
    const store = this
    const { dispatch, commit } = this
    this.dispatch = function boundDispatch(type, payload) {
      return dispatch.call(store, type, payload)
    }
    this.commit = function boundCommit(type, payload, options) {
      return commit.call(store, type, payload, options)
    }

    // strict mode
    this.strict = strict
    /**
     * 安装模块
     */
    const state = this._modules.root.state
    // init root module
    // this also recursively registers all sub-modules and collects all module getters inside this._wrappedGetters
    installModule(this, state, [], this._modules.root)

    // initialize the store vm, which is responsible for reactivity (also registers _wrappedGetters as computed properties)
    resetStoreVM(this, state)

    // apply plugins
    plugins.forEach(plugin => plugin(this))

    if (Vue.config.devtools) {
      devtoolPlugin(this)
    }
  }
}
```

### 初始化模块

Vuex 将 store 分割成模块 (module)，每个模块拥有自己的 state, mutation, action, getter，并支持嵌套子模块，模块的设计就是一个树形结构

```javascript
// src/module/module-collection.js
export default class ModuleCollection {
  /**
   * ModuleCollection 实例化的过程就是执行了 register 方法
   */
  constructor(rawRootModule) {
    // register root module (Vuex.Store options)
    this.register([], rawRootModule, false)
  }

  get(path) {
    /**
     * path 是它父模块的 path
     * 通过 Module 的 getChild 方法一层层找到对应的模块
     */
    return path.reduce((module, key) => {
      return module.getChild(key)
    }, this.root)
  }

  getNamespace(path) {
    let module = this.root
    return path.reduce((namespace, key) => {
      module = module.getChild(key)
      return namespace + (module.namespace ? key + "/" : "")
    }, "")
  }

  update(rawRootModule) {
    update([], this.root, rawRootModule)
  }

  register(path, rawModule, runtime = true) {
    /**
     * path 表示路径，因为整体目标是要构建一颗模块树，path 是构建树的过程中维护的路径
     * rawModule 表示定义模块的原始配置
     * runtime 表示是否是一个运行时创建的模块
     */
    // assertRawModule(path, rawModule)

    /**
     * 创建一个 Module 实例
     * 判断当前 path 的长度如果为 0，说明这是一个根模块，赋值给 this.root
     * 否则建立父子关系，也就是调用 Module 的 addChild 方法
     */
    const newModule = new Module(rawModule, runtime)
    if (path.length === 0) {
      this.root = newModule
    } else {
      const parent = this.get(path.slice(0, -1))
      parent.addChild(path[path.length - 1], newModule)
    }

    // register nested modules
    /**
     * 最后遍历当前模块定义的所有 modules，递归调用 register 方法
     */
    if (rawModule.modules) {
      forEachValue(rawModule.modules, (rawChildModule, key) => {
        this.register(path.concat(key), rawChildModule, runtime)
      })
    }
  }

  unregister(path) {
    const parent = this.get(path.slice(0, -1))
    const key = path[path.length - 1]
    if (!parent.getChild(key).runtime) return

    parent.removeChild(key)
  }
}
```

Module 用来描述单个模块的类

```javascript
// src/module/module.js
export default class Module {
  /**
   * this._rawModule 表示模块的配置
   * this._children 表示它的所有子模块
   * this.state 表示这个模块定义的 state
   */
  constructor(rawModule, runtime) {
    this.runtime = runtime
    // Store some children item
    this._children = Object.create(null)
    // Store the origin module object which passed by programmer
    this._rawModule = rawModule
    const rawState = rawModule.state

    // Store the origin module's state
    this.state = (typeof rawState === "function" ? rawState() : rawState) || {}
  }

  get namespaced() {
    return !!this._rawModule.namespaced
  }

  addChild(key, module) {
    this._children[key] = module
  }

  removeChild(key) {
    delete this._children[key]
  }

  getChild(key) {
    return this._children[key]
  }

  update(rawModule) {
    this._rawModule.namespaced = rawModule.namespaced
    if (rawModule.actions) {
      this._rawModule.actions = rawModule.actions
    }
    if (rawModule.mutations) {
      this._rawModule.mutations = rawModule.mutations
    }
    if (rawModule.getters) {
      this._rawModule.getters = rawModule.getters
    }
  }

  forEachChild(fn) {
    forEachValue(this._children, fn)
  }

  forEachGetter(fn) {
    if (this._rawModule.getters) {
      forEachValue(this._rawModule.getters, fn)
    }
  }

  forEachAction(fn) {
    if (this._rawModule.actions) {
      forEachValue(this._rawModule.actions, fn)
    }
  }

  forEachMutation(fn) {
    if (this._rawModule.mutations) {
      forEachValue(this._rawModule.mutations, fn)
    }
  }
}
```

### 安装模块

```javascript
function installModule(store, rootState, path, module, hot) {
  const isRoot = !path.length
  /**
   * 默认情况：模块内部的 action, mutation, getter 注册在全局命名空间
   * namespaced: true 的配置可以模块带有命名空间，访问这些属性需要带上模块注册的路径
   */
  const namespace = store._modules.getNamespace(path)

  // register in namespace map
  /**
   * 把 namespace 对应的模块保存下来，方便以后能根据 namespace 查找模块
   */
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module
  }

  // set state
  if (!isRoot && !hot) {
    const parentState = geNestedState(rootState, path.slice(0, -1))
    const moduleName = path[path.length - 1]
    store._withCommit(() => {
      Vue.set(parentState, moduleName, module.state)
    })
  }

  const local = (module.context = makeLocalContext(store, namespace, path))

  module.forEachMutation((mutation, key) => {
    const namespacedType = namespace + key
    registerMutation(store, namespacedType, mutation, local)
  })

  module.forEachAction((action, key) => {
    const type = action.root ? key : namespace + key
    const handler = action.handler || action
    registerAction(store, type, handler, local)
  })

  module.forEachGetter((getter, key) => {
    const namespacedType = namespace + key
    registerGetter(store, type, handler, local)
  })

  module.forEachChild((child, key) => {
    installModule(store, rootState, path.concat(key), cihld, hot)
  })
}
```

```javascript
function makeLocalContext(store, namespace, path) {
  const noNamespace = namespace === ""

  const local = {
    dispatch: noNamespace
      ? store.dispatch
      : (_type, _payload, _options) => {
          const args = unifyObjectStyle(_type, _payload, _options)
          const { payload, options } = args
          let { type } = args
          if (!options || !options.root) {
            type = namespace + type
            if (
              process.env.NODE_ENV !== "production" &&
              !store._actions[type]
            ) {
              // warn(vuex unknown local action type: ${args.type}, global type: ${type})
              return
            }
          }
          return store.dispatch(type, payload)
        },
    commit: noNamespace
      ? store.commit
      : (_type, _payload, _options) => {
          const args = unifyObjectStyle(_type, _payload, _options)
          const { payload, options } = args
          let { type } = args
          if (!options || !options.root) {
            type = namespace + type
            if (
              process.env.NODE_ENV !== "production" &&
              !store._mutations[type]
            ) {
              // warn(vuex unknown local mutation type ...)
              return
            }
          }
          return store.commit(type, payload, options)
        },
  }

  // getters and state object must be gotten lazily because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? () => store.getters
        : () => makeLocalGetters(store, namespace),
    },
    state: {
      get: () => getNestedState(store.state, path),
    },
  })

  return local
}
``` 
