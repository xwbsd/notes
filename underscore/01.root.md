## 组织工具函数库

```javascript
;(function () {
  var root = this

  var _ = {}

  root._ = _

  // 在这里添加自己的方法
  _.reverse = function (string) {
    return string.split("").reverse().join("")
  }
})()
```

我们将所有的方法添加到一个名为 `_` 的对象上，然后将其挂载到全局对象上。

在浏览器环境下 this 相当于 window，也就是 window._ = _，但是工具函数不仅要求运行在浏览器端，还希望其运行在诸如 Node 等环境。

## root

我们想通过 `var root = this` 获取全局对象，但是严格模式，this 返回 undefined，即使不采用严格模式，在 ES6 的模块脚本也将自动采用严格模式，无论是否声明 `use strict`

```javascript
var root = (typeof window == "object" ? window.window == window && window) ||
  (typeof global == "object" ? global.global == global && global)
```

### Web Worker

> 在 Web Worker 标准中，定义了解决客户端 JavaScript 无法多线程的问题。其中定义的 "worker" 是指执行代码的并行过程。不过，Web Worker 处在一个自包含的执行环境中，无法访问 Window 对象和 Document 对象，和主线程之间的通信也只能通过异步消息传递机制来实现

所以 Web Worker 中的 window 和 global 也将是 undefined，但我们可以通过 self 访问到 Worker 环境中的全局对象。而且浏览器环境中 self 也能直接访问到 window 对象

```javascript
console.log(window.window === window) // true
console.log(window.self === window) // true
```

```javascript
var root = (typeof self == "object" ? self.self == self && self) ||
  (typeof global == "object" ? global.global == global && global)
```

### node vm

在 node 的 vm 模块（沙盒模块）中，runInContext 方法中，既不存在 window，也不存在 global。但是却可以用 this 来访问全局对象

```javascript
var root = (typeof self == "object" ? self.self == self && self) ||
  (typeof global == "object" ? global.global == global && global) ||
  this
```

### 微信小程序

在微信小程序中，window 和 global 都是 undefined，又因为强制使用严格模式 this 为 undefined

```javascript
var root = (typeof self == "object" ? self.self == self && self) ||
  (typeof global == "object" ? global.global == global && global) ||
  this ||
  {}
```
