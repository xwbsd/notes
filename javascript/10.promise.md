## 基础框架

```javascript
function Promise(executor) {
  // 2.1 Promise 的状态
  // Promise 必须处于以下三种状态之一: pending, fulfilled, rejected
  this.state = "pending"
  // 2.2.6.1 如果 Promise 处于 fulfilled 状态，所有相应的 onFulfilled 回调必须按照它们对应的 then 的原始调用顺序
  this.onFulfilledCallback = []
  // 2.2.6.2 如果 Promise 处于 rejected 状态，所有相应的 onRejected 回调必须按照它们对应的 then 的原始调用顺序
  this.onRejectedCallback = []

  const self = this

  function resolve(value) {
    setTimeout(function () {
      // 2.1.1 当 Promise 处于 pending 状态时
      // 2.1.1.1 可以转换到 fulfilled 或 rejected 状态
      // 2.1.2 当 Promise 处于 fulfilled 状态时
      // 2.1.2.1 不得过渡到任何其他状态
      // 2.1.2.2 必须有一个不能改变的值
      if (self.state === "pending") {
        self.state = "fulfilled"
        self.data = value
        // 2.2.6.1 如果 Promise 处于 fulfilled 状态，所有相应的 onFulfilled 回调必须按照它们对应的 then 的原始调用顺序
        for (let i = 0; i < self.onFulfilledCallback.length; i++) {
          self.onFulfilledCallback[i](value)
        }
      }
    })
  }

  function reject(reason) {
    setTimeout(function () {
      // 2.1.1 当 Promise 处于 pending 状态时
      // 2.1.1.1 可以转换到 fulfilled 或 rejected 状态
      // 2.1.3 当 Promise 处于 rejected 状态时
      // 2.1.2.1 不得过渡到任何其他状态
      // 2.1.2.2 必须有一个不能改变的值
      if (self.state === "pending") {
        self.state = "rejected"
        self.data = reason
        // 2.2.6.2 如果 Promise 处于 rejected 状态，所有相应的 onRejected 回调必须按照它们对应的 then 的原始调用顺序
        for (let i = 0; i < self.onRejectedCallback.length; i++) {
          self.onRejectedCallback[i](value)
        }
      }
    })
  }

  // 补充说明：用户传入的函数可能也会执行异常，所以这里用 try...catch 包裹
  try {
    executor(resolve, reject)
  } catch (reason) {
    reject(reason)
  }
}
```

## then 方法

```javascript
// 2.2 then 方法
// 一个 Promise 必须提供一个 then 方法来访问其当前值或最终值或 rejected 的原因
// 一个 Promise 的 then 方法接收两个参数
Promise.prototype.then = function (onFulfilled, onRejected) {
  const self = this

  let promise2
  // 2.2.7 then 必须返回一个 promise
  return (promise2 = new Promise(function (resolve, reject) {
    // 2.2.2 如果 onFulfilled 是一个函数
    // 2.2.2.1 它必须在 Promise 的状态变成 fulfilled 后被调用，并将 promise 的值作为它的第一个参数
    // 2.2.2.2 它一定不能在 Promise 的状态变成 fulfilled 前被调用
    // 2.2.2.3 它最多只能被调用一次
    if (self.state === "fulfilled") {
      // 2.2.4 onFulfilled 或 onRejected 在执行上下文堆栈仅包含平台代码之前不得调用
      // 3.1 这可以通过 [宏任务] 机制 (setTimeout, setImmediate 等) 或 [微任务] 机制 (MutationObserver, process.nextTick) 来实现
      setTimeout(function () {
        // 2.2.1 onFulfilled 和 onRejected 都是可选参数
        // 2.2.1.1 如果 onFulfilled 不是一个函数，它必须被忽略
        if (typeof onFulfilled === "function") {
          try {
            // 2.2.2.1 它必须在 Promise 的状态变成 fulfilled 后被调用，并将 promise 的值作为它的第一个参数
            // 2.2.5 onFulfilled 和 onRejected 必须作为函数调用
            const x = onFulfilled(self.data)
            // 2.2.7.1 如果 onFulfilled 或 onRejected 返回了一个值 x，则运行 Promise 处理程序 [[Resolve]](promise2, x)
            promiseResolutionProcedure(promise2, x, resolve, reject)
          } catch (e) {
            // 2.2.7.2 如果 onFulfilled 或 onRejected 抛出了一个异常，promise2 必须用 e 作为 reason 来变为 rejected 状态
            reject(e)
          }
        } else {
          // 2.2.7.3 如果 onFulfilled 不是一个函数且 promise1 为 fulfilled 状态，promise2 必须用和 promise1 一样的值来变为 fulfilled 状态
          resolve(self.data)
        }
      })
    }
    // 2.2.3 如果 onRejected 是一个函数
    // 2.2.3.1 它必须在 Promise 的状态变成 rejected 后被调用，并将 promise 的 reason 作为它的第一个参数
    // 2.2.3.2 它一定不能在 Promise 的状态变成 rejected 前被调用
    // 2.2.3.3 它最多只能被调用一次
    else if (self.state === "rejected") {
      // 2.2.4 onFulfilled 或 onRejected 在执行上下文堆栈仅包含平台代码之前不得调用
      // 3.1 这可以通过 [宏任务] 机制 (setTimeout, setImmediate 等) 或 [微任务] 机制 (MutationObserver, process.nextTick) 来实现
      setTimeout(function () {
        // 2.2.1 onFulfilled 和 onRejected 都是可选参数
        // 2.2.1.2 如果 onRejected 不是一个函数，它必须被忽略
        if (typeof onRejected === "function") {
          try {
            // 2.2.3.1 它必须在 Promise 的状态变成 rejected 后被调用，并将 promise 的 reason 作为它的第一个参数
            // 2.2.5 onFulfilled 和 onRejected 必须作为函数调用
            const x = onRejected(self.data)
            // 2.2.7.1 如果 onFulfilled 或 onRejected 返回了一个值 x，则运行 Promise 处理程序 [[Resolve]](promise2, x)
            promiseResolutionProcedure(promise2, x, resolve, reject)
          } catch (e) {
            // 2.2.7.2 如果 onFulfilled 或 onRejected 抛出了一个异常，promise2 必须用 e 作为 reason 来变为 rejected 状态
            reject(e)
          }
        } else {
          // 2.2.7.4 如果 onRejected 不是一个函数且 promise1 为 rejected 状态，promise2 必须用和 promise1 一样的值来变为 rejected 状态
          reject(self.data)
        }
      })
    }
    // 2.2.6 then 可能会被同一个 Promise 多次调用
    else if (self.state === "pending") {
      // 2.2.6.1 如果 Promise 处于 fulfilled 状态，所有相应的 onFulfilled 回调必须按照它们对应的 then 的原始调用顺序
      self.onFulfilledCallback.push(function (promise1Value) {
        if (typeof onFulfilled === "function") {
          try {
            // 2.2.2.1 它必须在 Promise 的状态变成 fulfilled 后被调用，并将 promise 的值作为它的第一个参数
            // 2.2.5 onFulfilled 和 onRejected 必须作为函数调用
            const x = onFulfilled(self.data)
            // 2.2.7.1 如果 onFulfilled 或 onRejected 返回了一个值 x，则运行 Promise 处理程序 [[Resolve]](promise2, x)
            promiseResolutionProcedure(promise2, x, resolve, reject)
          } catch (e) {
            // 2.2.7.2 如果 onFulfilled 或 onRejected 抛出了一个异常，promise2 必须用 e 作为 reason 来变为 rejected 状态
            reject(e)
          }
        } else {
          // 2.2.7.3 如果 onFulfilled 不是一个函数且 promise1 为 fulfilled 状态，promise2 必须用和 promise1 一样的值来变为 fulfilled 状态
          resolve(promise1Value)
        }
      })
      // 2.2.6.2 如果 Promise 处于 rejected 状态，所有相应的 onRejected 回调必须按照它们对应的 then 的原始调用顺序
      self.onRejectedCallback.push(function (promise1Reason) {
        if (typeof onRejected === "function") {
          try {
            // 2.2.3.1 它必须在 Promise 的状态变成 rejected 后被调用，并将 promise 的 reason 作为它的第一个参数
            // 2.2.5 onFulfilled 和 onRejected 必须作为函数调用
            const x = onRejected(self.data)
            // 2.2.7.1 如果 onFulfilled 或 onRejected 返回了一个值 x，则运行 Promise 处理程序 [[Resolve]](promise2, x)
            promiseResolutionProcedure(promise2, x, resolve, reject)
          } catch (e) {
            // 2.2.7.2 如果 onFulfilled 或 onRejected 抛出了一个异常，promise2 必须用 e 作为 reason 来变为 rejected 状态
            reject(e)
          }
        } else {
          // 2.2.7.4 如果 onRejected 不是一个函数且 promise1 为 rejected 状态，promise2 必须用和 promise1 一样的值来变为 rejected 状态
          reject(promise1Reason)
        }
      })
    }
  }))
}
```
