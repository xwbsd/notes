> 常有人说async函数是generator函数的语法糖，async/await的行为就好像搭配使用了生成器和promise。

## generator

带星号的生成器函数，执行时遇到*yield*关键字，将返回关键字后面的内容，并暂停该函数的执行，可以通过*next*方法恢复执行。

```
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

var hw = helloWorldGenerator();

console.log(hw.next()); // {value: "hello", done: false}
console.log(hw.next()); // {value: "world", done: false}
console.log(hw.next()); // {value: "ending", done: true}
console.log(hw.next()); // {value: undefined, done: true}
```

#### 协程

比线程更加轻量级的存在，可视为线程上的任务，且不为内核管理，完全交由程序（用户）控制。

协程在主线程上交互执行，通过*yield*和*next*来配合。

#### generator和协程的配合

1. 通过生成器函数创建一个协程，后协程没有立即执行
2. 需调用*next*执行协程
3. 协程执行中遇到*yield*关键字将暂停并返回主要信息给父协程
4. 协程执行中遇到*return*关键字则结束当前协程并返回*return*后内容给父协程

## async

async函数*一定会返回一个promise对象*（如果一个async函数的返回值看起来不是promise，那么它将会被隐式地包装在一个promise中）

```
async function foo() {
   return 1
}
// 等价于
function foo() {
   return Promise.resolve(1)
}
---
async function foo() {
   await 1
}
// 等价于
function foo() {
   return Promise.resolve(1).then(() => undefined)
}
```

```
function* testG() {}

function asyncToGenerator(generatorFunc) {
    // 采用高阶函数的方式实现
    return function () {

        // 先调用generator函数，生成迭代器
        // var gen = testG()
        let gen = generatorFunc.apply(this, argments)

        // async函数默认返回的是promise对象，外部使用then或者await使用这个返回值
        // var test = asyncToGenerator(testG)
        // test.then(res => do something with res)
        return new Promise((resolve, reject) => {

            // 通过step函数来一步一步跨过yield阻碍（递归）
            // @param key: next | throw 对应gen的next和throw方法
            // @param arg 用来吧promise resolve的值交给下一个yield
            function step(key, arg) {
                let generatorResult

                // 通过trycatch把报错通过promise reject出去，外部通过catch来获取错误
                try {
                    generatorResult = gen[key](arg)
                } catch(error) {
                    return reject(error)
                }

                // gen.next()的返回结构是{ value, done }
                const { value, done } = generatorResult

                if (done) {
                    // done是在最后一次调用next后才会为true
                    // { value: value, done: true }
                    // 完成后resolve这个promise
                    // 这个value也是generator函数最后的返回值
                    return resolve(value)
                } else {
                    // 遇到yield时自动调用gen.next()
                    // { value: Promise, done: false }
                    // value也可以不是promise，这里兼容处理成promise
                    // 等待promise resolve后执行next
                    return Promise.resolve(value).then(
                        // 只要done不是true就会递归的往下解开promise
                        val => step('next', val),
                        // 如果promise被reject了
                        // 再次进入step函数调用的时try里的gen.throw(err)
                        // 之后自然就被catch到，然后把promise rejcet掉
                        err => step('throw', err)
                    )
                }
            }
            step('next')
        })
    }
}
```