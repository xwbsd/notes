路由切换时将执行 history.transitionTo 处理匹配到新路线后做了哪些事情

```javascript
// src/history/base.js
function transitionTo(
  location: RawLocation,
  onComplete?: function,
  onAbort?: function
) {
  /**
   * 根据目标 location 和当前路径 this.current 通过 match 匹配到目标路由
   * transitionTo 也就是在切换 this.current
   */
  const route = this.router.match(location, this.current);
  /**
   * 通过 confirmTransition 做真正的切换
   */
  this.confirmTransition(
    route,
    () => {
      this.updateRoute(route);
      onComplete && onComplete(route);
      this.ensureURL();
      if (!this.ready) {
        this.ready = true;
        this.readyCbs.forEach((cb) => {
          cb(route);
        });
      }
    },
    (err) => {
      if (onAbort) {
        onAbort(err);
      }
      if (err && !this.ready) {
        this.ready = true;
        this.readyErrorCbs.forEach((cb) => {
          cb(err);
        });
      }
    }
  );
}

// src/util/route.js
/**
 * this.current 在 history 的构造函数中初始化 this.current = START
 */
export const START = createRoute(null, {
  path: "/",
});
```

## confirmTransition

这个过程可能有一些异步的操作（异步组件），所以设计带有回调函数

```javascript
function confirmTransition(
  route: Route,
  onComplete: function,
  onAbort?: function
) {
  const current = this.current;
  const abort = (err) => {
    if (isError(err)) {
      if (this.errorCbs.length) {
        this.errorCbs.forEach((cb) => {
          cb(err);
        });
      } else {
        // warn(uncaught error during route navigation)
      }
    }
    onAbort && onAbort(err);
  };
  /**
   * 如果计算后的 route 和 current 是相同路径
   */
  if (
    isSameRoute(route, current) &&
    route.matched.length === current.matched.length
  ) {
    this.ensureURL();
    return abort();
  }
  /**
   * 通过 resolveQueue 解析 3 个队列 updated, activated, deactivated
   */
  const { updated, deactivated, activated } = resolveQueue(
    this.current.matched,
    route.matched
  );

  const queue = [].concat(
    extractLeaveGuards(deactivated),
    this.router.beforeHooks,
    extractUpdateHooks(updated),
    activated.map((m) => m.beforeEnter),
    resolveAsyncComponents(activated)
  );

  this.pending = route;
  const iterator = (hook, next) => {
    if (this.pending !== route) {
      return abort();
    }
    try {
      hook(route, current, (to) => {
        if (to === false || isError(to)) {
          this.ensureURL(true);
          abort(to);
        } else if (
          typeof to === "string" ||
          (typeof to === "object" &&
            (typeof to.path === "string" || typeof to.name === "string"))
        ) {
          abort();
          if (typeof to === "object" && to.replace) {
            this.replace(to);
          } else {
            this.push(to);
          }
        } else {
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, () => {
    const postEnterCbs = [];
    const isValid = () => this.current === route;
    const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    const queue = enterGuards.concat(this.router.resolveHooks);
    runQueue(queue, iterator, () => {
      if (this.pengding !== route) {
        return abort();
      }
      this.pending = null;
      onComplete(route);
      if (this.router.app) {
        this.router.app.$nextTick(() => {
          postEnterCbs.forEach((cb) => {
            cb();
          });
        });
      }
    });
  });
}

function resolveQueue(
  current: RouteRecord[],
  next: RouteRecord[]
): {
  updated: RouteRecord,
  activated: RouteRecord,
  deactivated: RouteRecord,
} {
  let i;
  const max = Math.max(current.length, next.length);
  /**
   * 路径由 current 变成 route，遍历对比两者数组，找到不一样的位置 i
   * next 从 0 到 i 的 RouteRecord 两边一样，为 updated 的部分
   * next 从 i 到最后是 next 独有的，为 activated 部分
   * current 从 i 到最后的 RouteRecord 则没有了，为 deactivated 部分
   */
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i),
  };
}
```

## runQueue

拿到 updated, activated, deactivated 3 个 RouteRecord 数组后，执行一系列钩子函数。首先构造一个队列 queue，再定义一个迭代器函数 iterator，最后再执行 runQueue 方法来执行这个队列

```javascript
// src/util/async.js
export function runQueue(
  queue?: NavigationGuard[],
  fn: function,
  cb: function
) {
  /**
   * 每次根据 index 从 queue 中取一个 guard
   * 然后执行 fn 函数，并把 guard 作为第一个参数传入
   * 第二个参数是一个函数，可以递归执行 step，前进到下一个
   */
  const step = (index) => {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], () => {
          step(inde + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/**
 * fn 就是 confirmTransition 中定义的 iterator
 * 就是执行每一个导航守卫 hook
 * 传入的 route, current, 匿名函数 对应文档中的 to, from, next
 * 执行匿名函数会根据一些条件执行 abort 或 next
 * 只有执行 next 才会前进到下一个导航守卫钩子函数中
 */
const iterator = (hook, next) => {
  if (this.pending !== route) {
    return abort();
  }
  try {
    hook(route, current, (to) => {
      if (to === false || isError(to)) {
        this.ensureURL(true);
        abort(to);
      } else if (
        typeof to === "string" ||
        (typeof to === "object" &&
          (typeof to.path === "string" || typeof to.name === "string"))
      ) {
        abort();
        if (typeof to === "object" && to.replace) {
          this.replace(to);
        } else {
          this.push(to);
        }
      } else {
        next(to);
      }
    });
  } catch (e) {
    abort(e);
  }
};
```
